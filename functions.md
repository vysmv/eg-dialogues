# Сравнение функций в PHP и Go

## Вступление
**Привет всем заглянувшим!** 

Это конспект, в котором описаны все темы, рассмотренные в видео.  

Сегодня мы разберём, как устроена логика работы с функциями в PHP и Go. Если материал показался вам полезным, не забывайте подписываться и ставить лайк.

## Описание стенда 
Два экрана: на одном — PHP, на втором — Go.  
Разбирается указанная тема параллельно, в формате сравнения.  
В процессе объяснения отличий демонстрируются примеры кода.

## Сравнение

### Общее
Функции в PHP очень похожи на функции Go и на функции во многих других языках.  
Это именованный фрагмент кода, у которого могут быть входные и выходные данные, а также программная логика по преобразованию входных данных в выходные.  

И PHP, и Go позволяют создавать собственные функции.

**В PHP:**
- ключевое слово `function`;  
- имя функции, начинающееся с буквы или символа подчёркивания;  
- круглые скобки, в которых указываются входные параметры;  
- опционально — возвращаемое значение;  
- фигурные скобки, в которых описывается тело;  
- вызов функции `foo()`;  
- описание функции может находиться ниже вызова. Интерпретатор выполняет код построчно, но определения функций компилируются заранее (function declarations hoisting);  
- функцию можно использовать как процедуру, если не применять `return`, либо объявить возврат типа `void` и использовать пустой `return`.  

```php
function foo(): int {
    return 2 + 2;
}
```

**В Go:**

- ключевое слово func;
- имя функции, начинающееся с буквы (строчной или заглавной);
- круглые скобки, в которых указываются входные параметры;
- возвращаемое значение указывается обязательно, если есть return;
- фигурные скобки, в которых описывается тело;
- вызов функции foo();
- описание функции может находиться ниже вызова. Причина здесь иная, чем в PHP: это связано с тем, как компилятор Go собирает программу;
- функцию можно использовать как процедуру, если не применять return.

```go
func foo(varName int) int {
    return varName + 2
}
```
### Различное 

#### 1. Философия 
Функции в PHP предполагают как гибкое, так и строгое использование. Можно работать с динамическими параметрами и передавать разные типы, полагаясь на логику преобразования. Но простота использования оплачивается повышенным риском ошибок в коде.  
В Go же функции всегда строго типизированы: типы входных и выходных данных определены однозначно. Это ярко отражает ключевую философию языков: гибкость (с возможностью строгой типизации) против классической инженерной строгости.

> **Наглядный пример гибкости в PHP.**  
> В PHP можно использовать `return` в теле функции, но не указывать тип возвращаемого значения в сигнатуре.  
> Визуально не всегда ясно, что именно вернёт функция при работе с разными типами. Для интерпретатора результат определён, но для человека, читающего код, может возникнуть неоднозначность.  

```php
<?php
declare(strict_types=1);

function foo( int $varName) {
    return $varName + '2'; // Тип возвращаемого значения визуально не ясен
}

echo foo(2) . PHP_EOL;
```

#### 2. Присваивание процедуры
В PHP и Go доступны процедуры — не как отдельные типы, а на уровне идеи. Например, интерпретатор PHP не возражает, если присвоить переменной результат вызова функции, которая ничего не возвращает (нет `return`), но при этом фактически возвращает `null`.

```php
<?php
declare(strict_types=1);

function foo() {
     echo 2 + 2 . PHP_EOL;
}

$x = foo();

echo gettype($x) . PHP_EOL;
```

В Go нельзя присвоить результат вызова функции, которая не имеет return (процедуры). Это ошибка компиляции.

```go
package main

import "fmt"

func foo() {
	fmt.Println("Hi!")
}

func main() {
     x := foo() // foo() (no value) used as value

}
```

#### 3. Множественный возврат
В Go можно вернуть более одного значения. В то время как в PHP только одно (хотя оно может быть составным типом — массивом или объектом).  

Пример в Go:

```go
package main

import (
    "fmt"
)

func foo(varName int) (int, bool) {
    flag := false
    if varName > 5 {
         flag = true
    }

    return varName + 2, flag
}

func main() {
    val1, val2 := foo(9)
    fmt.Println(val1, val2) // 11 true
}
```
В основном это используется для возврата информации об ошибке. Возврат ошибки вторым параметром — идиоматический стиль в Go, поскольку в языке нет конструкций try/catch. Здесь логика иная, но это уже отдельная тема.

#### 4. Именованные возвращаемые значения
В Go возвращаемым значениям можно дать имена на уровне сигнатуры (*named return values*). Это приводит к тому, что соответствующие переменные создаются в теле функции и инициализируются значениями по умолчанию (*zero values*). Далее в теле функции можно присваивать им новые значения, а ключевое слово `return` вернёт эти переменные, даже если их имена не указаны после `return`. В контексте общей логики Go это иногда оказывается удобным.

```go
package main

import (
    "fmt"
)

func foo(varName int) (result int, flag bool) {
    if varName > 5 {
        flag = true
    }
    result = varName + 2
    return
}

func main() {
    val1, val2 := foo(9)
    fmt.Println(val1, val2) // 11 true
}
```

#### 5. Условные объявления
В PHP можно объявлять функцию по условию. Но в этом случае её вызов должен находиться после объявления. Если условие не выполнится и функция не будет определена, попытка её вызова приведёт к ошибке.

```php
<?php
declare(strict_types=1);
$status = true;
if ($status) {
    function foo() : int {
         return 2+2;
    }
}

echo foo() . PHP_EOL;
```

В Go ветвления в глобальной области видимости невозможны. Различие связано с базовым устройством программы.
Go-файлы содержат объявления переменных, констант и функций, которые объединяются в модули и пакеты со специфическим способом подключения. Программа запускается с функции main (если не считать специальную функцию init), которая инициирует выполнение всего механизма.

В PHP всё проще: есть скрипт-точка входа, и в глобальной области можно писать полноценный код, используя все возможности языка. Подключение файлов осуществляется с помощью операторов require, include, а также их вариантов require_once и include_once.

```go
package main

import (
    "fmt"
)

var someCondition bool = false

func main() {
    foo()
    fmt.Printf("")
}

if someCondition { // syntax error: non-declaration statement outside function body
    func foo() {
        fmt.Printf("Hello!")
    }
}
```
Таким образом, функции по условию в Go могут быть только анонимными.

```go
package main

import "fmt"

var doSomething func()

func init() {
    if false {
        doSomething = func() {
            fmt.Println("Called version A")
        }
    } else {
        doSomething = func() {
            fmt.Println("Called version B")
        }
    }
}

func main() {
    doSomething() // Вызовет нужную реализацию
}
```

> Маленькая ремарка про init. 
>
> В PHP такой логики нет. 
> В Go можно объявить более одной функции с именем init — как в одном файле, так и в разных файлах одного пакета. Эта функция имеет особое назначение: она вызывается автоматически (и только автоматически) до запуска main. Как правило, её используют для предварительной настройки программы.
> 
> Порядок вызовов следующий:
>
> - сначала запускаются все init в импортируемых пакетах (в порядке зависимостей);
> - если в одном файле несколько init, они выполняются в порядке появления в коде;
> - если в разных файлах одного пакета — порядок между файлами не гарантируется (это зависит от компилятора), поэтому на него лучше не полагаться.

#### 6. Вложенные функции
В PHP внутри функции можно объявлять как именованные, так и анонимные функции.  

```php
<?php
declare(strict_types=1);

function foo() {
    function test() {
        return "I am test";
    }

    $anonymous = function() {
        return "I am anonymous";
    };

    return test() . " : " . $anonymous();
}

echo test(); // Error

echo foo() . PHP_EOL; // I am test : I am anonymous

echo test(); // Ok
```
Важно: вызывать вложенные функции в PHP можно только после того, как будет вызвана родительская функция, то есть после фактического исполнения объявления дочерних.

В Go внутри функций можно объявлять только анонимные функции. Именованные функции разрешено определять только в глобальной области, а анонимные — как в глобальной, так и внутри функций.
```go
package main

import "fmt"

var ga = func() string { return "global anonymous" } // OK

func main() {
    // func foo(){} // Error
    la := func() string { return "local anonymous" } // OK

    fmt.Println(la())
    fmt.Println(ga())
}
```

#### 7. Вариативность типов
В PHP есть концепция вариативности принимаемых и возвращаемых значений. Например, параметр может быть либо `null`, либо `int`, а возвращаемое значение — `bool` или `int`:

```php
<?php
declare(strict_types=1);

function foo(?int $age, int|string $id): bool|int {
    if ($age !== null && $age >= 0) {
        return 1;
    }

    return false;
}
```
Кроме того, в PHP появился механизм intersection types (пересечение типов, PHP 8.1): A&B означает, что объект должен реализовывать оба интерфейса. Возможны и комбинации, например:

```php
function foo((A&B)|null $value): (X&Y)|false {}
```
Расшифровка:

- параметр `$value` может быть объектом, который одновременно реализует `A` и `B`, или `null`;
- возвращаемое значение — либо объект, который одновременно реализует `X` и `Y`, либо `false`.

```php
<?php
declare(strict_types=1);

interface Loggable {}
interface Jsonable {}

class MyClass implements Loggable, Jsonable {}

function process((Loggable&Jsonable)|null $obj): bool {
    if ($obj === null) {
        return false;
    }
    return true;
}

$obj = new MyClass;
$result = process($obj);

echo gettype($result) . PHP_EOL; // boolean
```

В Go всё гораздо строже: каждый параметр и каждое возвращаемое значение имеют ровно один тип.
Небольшую гибкость добавили дженерики (Go 1.18+), но это уже отдельная тема — о ней поговорим в другой раз.

#### 8. Логика работы параметров и аргументов
Тут мы сделаем довольно глубокое погружение в тему — она того требует.  
В PHP при работе с функциями параметры могут ожидаться как копии, так и ссылки, или их комбинацией. По умолчанию предполагается, что параметр будет копией.  
Если необходимо, чтобы была ссылка, используем `&`.

```php
<?php
declare(strict_types=1);

// Вариант 1
$name = 'John'; // Оригинал

function foo($name) { // 2. Принимаем копию
    $name = 'Ivan'; // 3. Меняем копию
}

foo($name); // 1. Передаем копию

echo $name . PHP_EOL; // Оригинал не изменился
```
```php
<?php
declare(strict_types=1);

// Вариант 2
$name = 'John'; // Оригинал

function foo(&$name) { // 2. Принимаем ссылку
    $name = 'Ivan'; // 3. Меняем оригинал
}

foo($name); // 1. Передаем копию (?)

echo $name . PHP_EOL; // Оригинал изменился
```
Любопытно, что в PHP, в отличие от Go, на этапе передачи аргумента нет символа, отличающего передачу ссылки.

Например, в Go:
```go
foo(&name)
```

В PHP же символ `&` ставится в сигнатуре функции и указывает на ссылочный тип параметра:
```php
function foo(&$name) {}
```
В Go для параметров используется указатель (*), что более привычно для системных языков:
```go
func foo(name *string) {}
```
То есть в Go классический подход системных языков:

```go
// Вариант 1
package main

import "fmt"

func foo(name string) { // 2. Принимаем копию
    fmt.Println("[")
    fmt.Println("     Input: ", name)

    name = "Ivan" // 3. Меняем копию

    fmt.Println("     After changed: ", name)
    fmt.Println("]")
}

func main() {
    name := "John" // 0. Создаем оригинал

    foo(name) // 1. Передаем копию

    fmt.Println("Original: ", name) // Оригинал не изменился
}
```

```go
// Вариант 2
package main

import "fmt"

func foo(name *string) { // 2. Принимаем переменную типа указатель на string
    fmt.Println("[")
    fmt.Println("    Input: ", *name)

    *name = "Ivan" // 3. Разыменование и изменение оригинала

    fmt.Println("    After changed: ", *name)
    fmt.Println("]")
}

func main() {
    name := "John" // 0. Создаем оригинал

    foo(&name) // 1. Передаем ссылку

    fmt.Println("Original: ", name) // Оригинал изменился
}
```
Специальный символ `&`, добавленный к имени аргумента, говорит о передаче ссылки, а параметр в сигнатуре должен быть типа «указатель на…».

Но почему в PHP не соблюдается стандартная логика системных языков?
Что это за странное решение — при вызове функции вообще не видно, что передаётся, а в сигнатуре используется `&`?

Например, у меня в момент разбора этой темы возник вопрос:
«Если в момент вызова функции в PHP нет символа передачи по ссылке или по значению (они не различимы), и при этом по умолчанию передаётся копия, то как тогда в функцию может быть передана ссылка?»

Всё дело в том, как PHP работает с переменными.
Переменная `$a = 42;` образно в памяти выглядит так:

```bash
символ $a ──► zval { type=int, value=42, refcount=1, is_ref=0 }
```

То есть:

- `$a` — это символическая ссылка на контейнер zval (ярлык, указывающий на контейнер zval);
- zval хранит тип, значение и счётчик ссылок.

Когда вы пишете `$b = $a;`, создаётся ещё один символ, указывающий на тот же zval:
```bash
$a ─┐
     └──► zval { type=int, value=42, refcount=2, is_ref=0 }
$b ─┘
```

Если далее по коду выполняется присваивание вида `$b = 100;`, то срабатывает механизм copy-on-write: 
- создаётся новый zval, 
- `$a` остаётся со старым. 

То есть `$a` и `$b` разделились на две независимые копии и теперь указывают на два разных zval.

```bash
$a ──► zval { type=int, value=42, refcount=1, is_ref=0 }
$b ──► zval { type=int, value=100, refcount=1, is_ref=0 }
```

Важно уловить: до изменения копии она остаётся символической ссылкой на тот же zval, что и `$a`. Это и есть механизм отложенного копирования.

> Полезно! 
>
> На практике это означает, что нет разницы по скорости и потреблению памяти при передаче массива в функцию по ссылке или по значению, если массив не модифицируется в теле функции. [Опционально демонстрация теста]

Но переменная может быть скопирована и по ссылке.

Например:

```php
$a = 42;
$b = &$a;
```
В этом случае символ `&` приводит к созданию reference-контейнера. После этого и `$b`, и `$a` будут указывать на один и тот же reference-контейнер, содержащий исходный zval. Изменение `$a` или `$b` приведёт к изменению общих данных: 

```bash
до:
$a ──► [ zval { value=42 } ]

после $b = &$a;:
$a ──► [ REF { zval { value=42 } } ] ◄─ $b
        	(gc.refcount = 2)
```

**Эта логика распространяется и на вызовы функций!**

В PHP при вызове `foo($a);` вне зависимости от сигнатуры объявления функции:

- `foo(&$x)`
- `function foo($x)` 

будет передан указатель на структуру zval (или на reference-контейнер, если аргумент уже ссылка).

То есть у нас есть исходная переменная $a, которая является символьным именем для адреса структуры zval (или на reference-контейнер, если аргумент уже ссылка). На старте вызова функции будет передаваться этот указатель на базовый zval или на reference-контейнер.

Далее, в зависимости от наличия или отсутствия символа & перед параметром, будет определено, как интерпретатор привяжет этот zval к параметру:

- `function foo($x)` → создаётся новое имя `$x`, указывающее на тот же zval. При попытке модификации такой переменной будет выполнена проверка: если refcount > 1 и это не ссылочный контейнер, то сработает copy-on-write. 
- `function foo(&$x)` → движок говорит: «этот параметр обязан быть reference-контейнером (REF)». Поэтому в момент привязки к переменной $x указатель на zval из глобальной `$a` будет заменён на указатель на reference-контейнер, который уже содержит в себе изначальный zval.

В итоге:

- глобальная `$a` будет изменена с адреса zval на адрес reference-контейнера; 
- локальная $x будет содержать указатель на тот же reference-контейнер.

Таким образом, обе переменные будут ссылаться на один REF, содержащий общий zval. При модификации $x движок меняет значение напрямую внутри REF, так как copy-on-write не применяется к reference-контейнерам

**Итак, PHP в этом вопросе не “неправильный”, а просто следует другой логике реализации.**

#### 9. Значения по умолчанию

В PHP существует концепция значений по умолчанию: сначала указываются обязательные параметры, а затем — параметры со значениями по умолчанию.  

Важно: значение по умолчанию должно быть константным выражением — литералом, `null`, `true/false`, массивом-литералом и т.п. Нельзя использовать вызовы функций, оператор `new`, обращение к переменным и т.д.

```php
<?php
declare(strict_types=1);

function foo(int $id, bool $status = false) {
    echo $id . PHP_EOL;
    echo $status ? 'true' . PHP_EOL : 'false' . PHP_EOL;
}

foo(10);
```

В Go нет возможности задавать значения по умолчанию в сигнатуре функции.

#### 10. Вариативные параметры
В PHP предусмотрен механизм приёма неограниченного количества параметров с помощью `...$paramName`.

```php
<?php
function foo(...$stock) {
	var_dump($stock);
}
foo('mars', 'alenka', 'twix');
```

Есть возможность распаковать массив в аргументы при вызове функции:
```php
<?php
declare(strict_types=1);

function foo($name1, $name2, $name3) {
    echo "$name1, $name2, $name3";
}

$arr = ['mars', 'alenka', 'twix'];

foo(...$arr); // mars, alenka, twix
```

В Go тоже есть вариативные параметры, но с небольшими отличиями.
Мы можем указать, что принимаем вариативное количество параметров:
```go
func foo(params ...int) {}
```
Здесь мы говорим, что готовы принять ноль или больше параметров. В теле функции они будут доступны как срез params.
Вызов может выглядеть так:

```go
foo(1)
foo(10, 20, 30)
```
Или так:

```go
 arr := []int{10, 20, 30}
 foo(arr...)
```
А вот распаковать массив в набор фиксированных параметров, как в PHP, нельзя:
```go
package main

import "fmt"

func foo(name1, name2, name3 string) { // Причина!
    fmt.Println(name1, name2, name3)
}

func main() {
    arr := []string{"mars", "alenka", "twix"}
    foo(arr...) // ✅ ОШИБКА: cannot use arr (type []string) as type string in argument to foo
}
```

В обоих языках можно описывать сигнатуры, где сначала идут обязательные параметры, а затем — вариативные:
```go
package main

import "fmt"

func foo(request int, names ...string) {
    fmt.Println(request, names)
}

func main() {
    arr := []string{"mars", "alenka", "twix"}
    foo(2, arr...) // ✅ работает
}
```
```php
<?php
declare(strict_types=1);

function foo(int $request, ...$names) {
    echo $request . PHP_EOL;
    echo print_r($names, true);
}

$arr = ["mars", "alenka", "twix"];

foo(2, ...$arr);
```
В целом здесь лишь незначительные различия — общая идея сохранена.

#### 11. Позиционные и именованные аргументы.

В PHP есть два способа передавать аргументы:

- вызов с позиционными аргументами;
- вызов с именованными аргументами.

```php
<?php
declare(strict_types=1);

// Позиционные
function foo(string $par1, int $par2) {
    echo $par1 . PHP_EOL;
    echo $par2 . PHP_EOL;
} 

$valForPar1 = 'content'; 
$valForPar2 = 150;

foo($valForPar1, $valForPar2); 
```

```php
<?php
declare(strict_types=1);

// Именнованные
function foo(string $par1, int $par2) {
    echo $par1 . PHP_EOL;
    echo $par2 . PHP_EOL;
} 

$valForPar1 = 'content'; 
$valForPar2 = 150;

foo(par2: $valForPar2, par1: $valForPar1); 
```
Также в PHP можно распаковывать массив аргументов, и его ключи (если они строковые) могут выступать в качестве имён параметров. Тем самым становится возможным передавать значения без соблюдения порядка параметров.
```php
<?php
declare(strict_types=1);

function foo(string $par1, int $par2) {
    echo $par1 . PHP_EOL;
    echo $par2 . PHP_EOL;
} 

$data = [
    'par2' => 250,
    'par1' => 'content'
];
foo(...$data); 
```

В Go нет именованных аргументов при вызове функций.
Вызов всегда позиционный, и порядок строго фиксирован.

#### 12. Области видимости

Обсуждая функции, сложно обойти тему областей видимости. Начнём с PHP.  
Области видимости — это, по сути, границы доступности переменной. У PHP четыре области: глобальная (переменные, определённые вне функций или классов), локальная (в теле функции), статическая (*static* — переменные внутри функции с модификатором `static`, сохраняют значение между вызовами функции), область видимости объекта (*object/class scope*: `public`, `protected`, `private`). Хотя в рамках упрощения я затрону только две: глобальную и локальную.

```php
<?php
declare(strict_types=1);

$x = 5;
include('script-name.php'); // Будет доступна $x

echo $x . PHP_EOL; // 10

function foo() {
    echo "[" . PHP_EOL;
    echo "  " . $x . PHP_EOL; // Error
    $x = 42;
    echo "  " . $x . PHP_EOL; // 42
    echo "]" . PHP_EOL;
}

foo();

echo $x . PHP_EOL; // 10
```
```php
// script-name.php
<?php
declare(strict_types=1);

echo $x . PHP_EOL; // 5

$x = 10;
```

Из функции можно получить доступ к глобальным переменным.

Например:

- передав параметр по ссылке;
- используя ключевое слово global (alias глобальной переменной);
- используя глобальный массив $GLOBALS (изменение реального значения из глобальной области видимости). 
```php
<?php
declare(strict_types=1);

// По ссылке
$x = 10;

function foo(&$x) {
    $x = 100;
}

echo $x . PHP_EOL; // Оригинал неизменился

foo($x);

echo $x . PHP_EOL; // Оригинал изменился
```

```php
<?php
declare(strict_types=1);

// global
$x = 10;

function foo() {
    global $x; // Создаётся ссылка на тот же zval. Ещё один ярлык.
    $x = 100;
}

echo $x . PHP_EOL; // Оригинал неизменился

foo();

echo $x . PHP_EOL; // Оригинал изменился
```
```php
<?php
declare(strict_types=1);

// $GLOBALS
$x = 10;

function foo() {
    $GLOBALS['x'] = 100; // Меняем напрямую значение, без создания копий
}

echo $x . PHP_EOL; // Оригинал неизменился

foo();

echo $x . PHP_EOL; // Оригинал изменился
```

Вопрос с областями видимости в Go существенно отличается и, по сути, тянет на отдельную тему. Поэтому сейчас посмотрим только то, что касается функций.
Область видимости в Go это тоже самое что и в PHP, - контекст в коде, в котором идентификатор (переменная, константа, функция, тип и т.д.) доступен для использования.

**Локальная область видимости (Local Scope)**

Переменные, объявленные внутри функции, метода или блока (if, for, switch), доступны только внутри этой области.
```go
package main

import "fmt"

func foo() {
    a := 10 // локальная переменная

    if a > 5 {
        b := 20 // доступна только внутри этого блока
        fmt.Println(a, b) // OK!
    }

    // fmt.Println(b) // Ошибка: undefined: b
}

func main() {
    foo()
}
```

**Область пакета (Package Scope)**

Идентификаторы, объявленные вне функций с маленькой буквы, становятся доступными во всём файле и в других файлах того же пакета.

**Глобальная область видимости (Exported Identifiers)**

Идентификаторы, объявленные вне функций с большой буквы, становятся доступными во всём файле и в других файлах того же пакета.

Я упоминаю это только для полноты контекста. Более подробное объяснение требует существенного ухода в сторону.

**Блочная область (Block Scope)**

Это наиболее локальный тип области видимости. В Go можно объявлять переменные внутри блоков {} — в if, for, switch, select, case и даже в отдельных {}.

**Особенность: := и Shadowing**

Go позволяет переменным затенять (shadow) другие переменные с тем же именем в более локальной области:

```go
package main

import "fmt"

func foo() {
    x := 10
    if true {
        x := 20 // затеняет внешний x
        fmt.Println(x) // 20
    }
    fmt.Println(x) // 10
}

func main() {
    foo()
}
```

#### 13. Переменные функции и анонимные функции

В PHP есть возможность создавать переменные функций.  
Например:

```php
<?php
declare(strict_types=1);

function sum(int|float ...$numbers): int|float {
    return array_sum($numbers);
}

$x = 'sum';

if (is_callable($x)) {
    echo $x(1, 2, 3, 4, 5) . PHP_EOL;
} else {
    echo 'Not Callable' . PHP_EOL;
}

// В качестве переменной функции не могут быть ключевые слова типа:
// isset, empty, echo, include, require
$y = 'echo';

// $y('work'); // Error
```

Анонимные функции в PHP требуют более глубокого погружения. И так как мы изучаем функции, то погружаемся.

**Замыкания (Closure) в PHP**

Closure — это специальный встроенный класс в PHP, который представляет анонимные функции (лямбды).
Когда мы создаём анонимную функцию, PHP автоматически превращает её в объект класса Closure.

То есть запись выражения:
```php
$a = function() { return 2 + 2; };
```
на самом деле является синтаксическим сахаром для создания объекта класса Closure.

**Связь Closure и callable**

Тип callable в PHP — это не отдельный тип данных, а просто обозначение чего-то, что можно вызвать.
Объекты класса Closure являются callable, но callable включает не только Closure, но и:

- имена обычных функций:

```php
function foo() { return "Hello"; }
$a = 'foo';
var_dump(is_callable($a)); // true
```

- массивы с методами классов:

```php
class Bar {
	static function baz() { return "World"; }
}
$b = ['Bar', 'baz'];
var_dump(is_callable($b)); // true
```

- объекты с __invoke():

```php
class MyCallable {
	public function __invoke() {
     	return "I was called!";
	}
}
$c = new MyCallable();
var_dump(is_callable($c)); // true
```

**Методы Closure**

Так как Closure — это объект, у него есть методы: bindTo(), call().

Пример с bindTo():
```php
class Test {
    private $value = 10;
}

$obj = new Test();

$func = function() {
    return $this->value * 2; // Попробуем обратиться к private-свойству
};

// Привяжем объект $obj к анонимной функции
$boundFunc = $func->bindTo($obj, 'Test');

echo $boundFunc(); // 20
```

Пример использования call():
```php
class User {
	private $name = "John";
}

$user = new User();

$func = function() {
	return "Hello, " . $this->name;
};

echo $func->call($user); // "Hello, John"
```

Метод call() делает почти то же самое, что и bindTo(), но сразу выполняет функцию с переданным контекстом.

**Способы вызова анонимной функции**

Прямой вызов через переменную:

```php
$func = function($x) {
	return $x * 2;
};

echo $func(5); // 10
```

Вызов сразу после объявления:

```php
echo (function($x) { return $x * 2; })(5); // 10
```
Вызов через call_user_func():
```php
$func = function() { return "Hello!"; };
echo call_user_func($func); // "Hello!"
```

Вызов с call_user_func_array() (если аргументы — массив):

```php
$func = function($a, $b) {
	return $a + $b;
};

echo call_user_func_array($func, [3, 7]); // 10
```

Вызов метода объекта через Closure::fromCallable():

```php
class Test {
	public function hello($name) {
     	     return "Hello, $name!";
	}
}

$obj = new Test();
$func = Closure::fromCallable([$obj, 'hello']);

echo $func("John"); // "Hello, John!"
```

**А как с этим в GO?**
В Go нельзя создавать переменные функций в строковом виде:

```go
package main

import "fmt"

func foo() {
    fmt.Println("")
}

func main() {
    f := "foo"
    f() // Error
}
```

Но можно так: 

- создать переменную функционального типа; 
- присвоить в нее функцию.

```go
package main

import "fmt"

func sum(nums ...int) int {
    s := 0
    for _, n := range nums {
         s += n
    }
    return s
}

func main() {
    // Переменная-функция совместимого типа
    var x func(...int) int = sum

 
    fmt.Println(x(1, 2, 3, 4, 5)) // 15
}
```

Аналога функции is_callable в Go нет. Логика другая: вызов может происходить только у функционального типа. Вызов может происходить только у функционального типа. При попытке вызова переменной со строкой или с массивом, ошибка будет еще на этапе компиляции.

**Анонимные функции**

В Go есть функциональные литералы — функции без имени:

```go
double := func(x int) int { return 2 * x }
_ = double(5)

_ = func(x int) int { return x * 2 }(5) // немедленный вызов (IIFE)
```
У функции-литерала нет имени; при присваивании переменной она не «становится методом/объектом» — это по-прежнему просто значение функционального типа.

**Вызов анонимной функции в Go**

- прямой вызов через переменную: fn(args...);
- немедленный вызов (IIFE): func(...) {...}(args...);
- поддержка вариативных аргументов и раскрытия среза ....

#### 14. Замыкания

Есть ещё тема, связанная с понятием замыкания (*closure*). Здесь речь не про класс `Closure` и его объекты — «анонимные функции» в PHP, — а про возможность «замкнуть» в себе значение переменных.

 ```php
<?php
declare(strict_types=1);

// В PHP значения можно замкнуть через копирование
$x = 100;
$data = [1, 2, 3, 4, 5];

$sum = function (int|float ...$numbers) use ($x): int|float {
    return array_sum($numbers) + $x;
}; // Символ ; важен

echo $sum(...$data) . PHP_EOL; // 115

$x = 200;
$data = [1, 2, 3, 4, 5, 6];

echo $sum(...$data) . PHP_EOL; // 121

echo '===============================' . PHP_EOL;

// Или мы можем замкнуть ссылку
$y = 200;
$data = [1, 2, 3, 4, 5];

$sum = function (int|float ...$numbers) use (&$y): int|float {
    return array_sum($numbers) + $y;
}; // Символ ; важен

echo $sum(...$data) . PHP_EOL; // 215

$y = 300;
$data = [1, 2, 3, 4, 5, 6];

echo $sum(...$data) . PHP_EOL; // 321 — так как замкнута ссылка и видны внешние изменения.
```

**А как с замыканием контекста в Go?**

Замыкание возникает, когда функциональный литерал использует переменные внешней лексической области.
Захватываются переменные (их адреса), а не значения. Поэтому дальнейшие изменения видны всем замыканиям, захватившим эту переменную.

Компилятор сам «продлевает жизнь» захваченной переменной (escape analysis), чтобы она существовала столько, сколько нужно замыканию.

Есть важное смысловое отличие:

- В PHP по умолчанию замыкается значение переменной — независимая копия. Внешняя переменная может быть изменена или уничтожена, но переменная в замыкании останется неизменной.
- В Go, напротив, по умолчанию замыкается ссылка. То есть в анонимной функции будет замкнут адрес переменной. Следовательно, внешняя и внутренняя переменные будут иметь одно общее значение.
